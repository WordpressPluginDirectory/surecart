function getSide(t){return t.split("-")[0]}function getAlignment(t){return t.split("-")[1]}function getMainAxisFromPlacement(t){return["top","bottom"].includes(getSide(t))?"x":"y"}function getLengthFromAxis(t){return"y"===t?"height":"width"}function computeCoordsFromPlacement(t,e,n){let{reference:o,floating:i}=t;const r=o.x+o.width/2-i.width/2,l=o.y+o.height/2-i.height/2,s=getMainAxisFromPlacement(e),c=getLengthFromAxis(s),a=o[c]/2-i[c]/2,f="x"===s;let g;switch(getSide(e)){case"top":g={x:r,y:o.y-i.height};break;case"bottom":g={x:r,y:o.y+o.height};break;case"right":g={x:o.x+o.width,y:l};break;case"left":g={x:o.x-i.width,y:l};break;default:g={x:o.x,y:o.y}}switch(getAlignment(e)){case"start":g[s]-=a*(n&&f?-1:1);break;case"end":g[s]+=a*(n&&f?-1:1)}return g}const computePosition$1=async(t,e,n)=>{const{placement:o="bottom",strategy:i="absolute",middleware:r=[],platform:l}=n,s=await(null==l.isRTL?void 0:l.isRTL(e));let c=await l.getElementRects({reference:t,floating:e,strategy:i}),{x:a,y:f}=computeCoordsFromPlacement(c,o,s),g=o,m={},d=0;for(let n=0;n<r.length;n++){const{name:u,fn:p}=r[n],{x:h,y:w,data:y,reset:x}=await p({x:a,y:f,initialPlacement:o,placement:g,strategy:i,middlewareData:m,rects:c,platform:l,elements:{reference:t,floating:e}});a=null!=h?h:a,f=null!=w?w:f,m={...m,[u]:{...m[u],...y}},x&&d<=50&&(d++,"object"==typeof x&&(x.placement&&(g=x.placement),x.rects&&(c=!0===x.rects?await l.getElementRects({reference:t,floating:e,strategy:i}):x.rects),({x:a,y:f}=computeCoordsFromPlacement(c,g,s))),n=-1)}return{x:a,y:f,placement:g,strategy:i,middlewareData:m}};function expandPaddingObject(t){return{top:0,right:0,bottom:0,left:0,...t}}function getSideObjectFromPadding(t){return"number"!=typeof t?expandPaddingObject(t):{top:t,right:t,bottom:t,left:t}}function rectToClientRect(t){return{...t,top:t.y,left:t.x,right:t.x+t.width,bottom:t.y+t.height}}async function detectOverflow(t,e){var n;void 0===e&&(e={});const{x:o,y:i,platform:r,rects:l,elements:s,strategy:c}=t,{boundary:a="clippingAncestors",rootBoundary:f="viewport",elementContext:g="floating",altBoundary:m=!1,padding:d=0}=e,u=getSideObjectFromPadding(d),p=s[m?"floating"===g?"reference":"floating":g],h=rectToClientRect(await r.getClippingRect({element:null==(n=await(null==r.isElement?void 0:r.isElement(p)))||n?p:p.contextElement||await(null==r.getDocumentElement?void 0:r.getDocumentElement(s.floating)),boundary:a,rootBoundary:f,strategy:c})),w=rectToClientRect(r.convertOffsetParentRelativeRectToViewportRelativeRect?await r.convertOffsetParentRelativeRectToViewportRelativeRect({rect:"floating"===g?{...l.floating,x:o,y:i}:l.reference,offsetParent:await(null==r.getOffsetParent?void 0:r.getOffsetParent(s.floating)),strategy:c}):l[g]);return{top:h.top-w.top+u.top,bottom:w.bottom-h.bottom+u.bottom,left:h.left-w.left+u.left,right:w.right-h.right+u.right}}const min$1=Math.min,max$1=Math.max;function within(t,e,n){return max$1(t,min$1(e,n))}const hash$1={left:"right",right:"left",bottom:"top",top:"bottom"};function getOppositePlacement(t){return t.replace(/left|right|bottom|top/g,(t=>hash$1[t]))}function getAlignmentSides(t,e,n){void 0===n&&(n=!1);const o=getAlignment(t),i=getMainAxisFromPlacement(t),r=getLengthFromAxis(i);let l="x"===i?o===(n?"end":"start")?"right":"left":"start"===o?"bottom":"top";return e.reference[r]>e.floating[r]&&(l=getOppositePlacement(l)),{main:l,cross:getOppositePlacement(l)}}const hash={start:"end",end:"start"};function getOppositeAlignmentPlacement(t){return t.replace(/start|end/g,(t=>hash[t]))}function getExpandedPlacements(t){const e=getOppositePlacement(t);return[getOppositeAlignmentPlacement(t),e,getOppositeAlignmentPlacement(e)]}const flip=function(t){return void 0===t&&(t={}),{name:"flip",options:t,async fn(e){var n;const{placement:o,middlewareData:i,rects:r,initialPlacement:l,platform:s,elements:c}=e,{mainAxis:a=!0,crossAxis:f=!0,fallbackPlacements:g,fallbackStrategy:m="bestFit",flipAlignment:d=!0,...u}=t,p=getSide(o),h=[l,...g||(p!==l&&d?getExpandedPlacements(l):[getOppositePlacement(l)])],w=await detectOverflow(e,u),y=[];let x=(null==(n=i.flip)?void 0:n.overflows)||[];if(a&&y.push(w[p]),f){const{main:t,cross:e}=getAlignmentSides(o,r,await(null==s.isRTL?void 0:s.isRTL(c.floating)));y.push(w[t],w[e])}if(x=[...x,{placement:o,overflows:y}],!y.every((t=>t<=0))){var v,R;const t=(null!=(v=null==(R=i.flip)?void 0:R.index)?v:0)+1,e=h[t];if(e)return{data:{index:t,overflows:x},reset:{placement:e}};let n="bottom";switch(m){case"bestFit":{var b;const t=null==(b=x.map((t=>[t,t.overflows.filter((t=>t>0)).reduce(((t,e)=>t+e),0)])).sort(((t,e)=>t[1]-e[1]))[0])?void 0:b[0].placement;t&&(n=t);break}case"initialPlacement":n=l}if(o!==n)return{reset:{placement:n}}}return{}}}};async function convertValueToCoords(t,e){const{placement:n,platform:o,elements:i}=t,r=await(null==o.isRTL?void 0:o.isRTL(i.floating)),l=getSide(n),s=getAlignment(n),c="x"===getMainAxisFromPlacement(n),a=["left","top"].includes(l)?-1:1,f=r&&c?-1:1,g="function"==typeof e?e(t):e;let{mainAxis:m,crossAxis:d,alignmentAxis:u}="number"==typeof g?{mainAxis:g,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...g};return s&&"number"==typeof u&&(d="end"===s?-1*u:u),c?{x:d*f,y:m*a}:{x:m*a,y:d*f}}const offset=function(t){return void 0===t&&(t=0),{name:"offset",options:t,async fn(e){const{x:n,y:o}=e,i=await convertValueToCoords(e,t);return{x:n+i.x,y:o+i.y,data:i}}}};function getCrossAxis(t){return"x"===t?"y":"x"}const shift=function(t){return void 0===t&&(t={}),{name:"shift",options:t,async fn(e){const{x:n,y:o,placement:i}=e,{mainAxis:r=!0,crossAxis:l=!1,limiter:s={fn:t=>{let{x:e,y:n}=t;return{x:e,y:n}}},...c}=t,a={x:n,y:o},f=await detectOverflow(e,c),g=getMainAxisFromPlacement(getSide(i)),m=getCrossAxis(g);let d=a[g],u=a[m];if(r){const t="y"===g?"bottom":"right";d=within(d+f["y"===g?"top":"left"],d,d-f[t])}if(l){const t="y"===m?"bottom":"right";u=within(u+f["y"===m?"top":"left"],u,u-f[t])}const p=s.fn({...e,[g]:d,[m]:u});return{...p,data:{x:p.x-n,y:p.y-o}}}}},size=function(t){return void 0===t&&(t={}),{name:"size",options:t,async fn(e){const{placement:n,rects:o,platform:i,elements:r}=e,{apply:l,...s}=t,c=await detectOverflow(e,s),a=getSide(n),f=getAlignment(n);let g,m;"top"===a||"bottom"===a?(g=a,m=f===(await(null==i.isRTL?void 0:i.isRTL(r.floating))?"start":"end")?"left":"right"):(m=a,g="end"===f?"top":"bottom");const d=max$1(c.left,0),u=max$1(c.right,0),p=max$1(c.top,0),h=max$1(c.bottom,0),w={availableHeight:o.floating.height-(["left","right"].includes(n)?2*(0!==p||0!==h?p+h:max$1(c.top,c.bottom)):c[g]),availableWidth:o.floating.width-(["top","bottom"].includes(n)?2*(0!==d||0!==u?d+u:max$1(c.left,c.right)):c[m])},y=await i.getDimensions(r.floating);null==l||l({...e,...w});const x=await i.getDimensions(r.floating);return y.width!==x.width||y.height!==x.height?{reset:{rects:!0}}:{}}}};function isWindow(t){return t&&t.document&&t.location&&t.alert&&t.setInterval}function getWindow(t){if(null==t)return window;if(!isWindow(t)){const e=t.ownerDocument;return e&&e.defaultView||window}return t}function getComputedStyle$1(t){return getWindow(t).getComputedStyle(t)}function getNodeName(t){return isWindow(t)?"":t?(t.nodeName||"").toLowerCase():""}function getUAString(){const t=navigator.userAgentData;return null!=t&&t.brands?t.brands.map((t=>t.brand+"/"+t.version)).join(" "):navigator.userAgent}function isHTMLElement(t){return t instanceof getWindow(t).HTMLElement}function isElement(t){return t instanceof getWindow(t).Element}function isNode(t){return t instanceof getWindow(t).Node}function isShadowRoot(t){return"undefined"!=typeof ShadowRoot&&(t instanceof getWindow(t).ShadowRoot||t instanceof ShadowRoot)}function isOverflowElement(t){const{overflow:e,overflowX:n,overflowY:o}=getComputedStyle$1(t);return/auto|scroll|overlay|hidden/.test(e+o+n)}function isTableElement(t){return["table","td","th"].includes(getNodeName(t))}function isContainingBlock(t){const e=/firefox/i.test(getUAString()),n=getComputedStyle$1(t);return"none"!==n.transform||"none"!==n.perspective||"paint"===n.contain||["transform","perspective"].includes(n.willChange)||e&&"filter"===n.willChange||e&&!!n.filter&&"none"!==n.filter}function isLayoutViewport(){return!/^((?!chrome|android).)*safari/i.test(getUAString())}const min=Math.min,max=Math.max,round=Math.round;function getBoundingClientRect(t,e,n){var o,i,r,l;void 0===e&&(e=!1),void 0===n&&(n=!1);const s=t.getBoundingClientRect();let c=1,a=1;e&&isHTMLElement(t)&&(c=t.offsetWidth>0&&round(s.width)/t.offsetWidth||1,a=t.offsetHeight>0&&round(s.height)/t.offsetHeight||1);const f=isElement(t)?getWindow(t):window,g=!isLayoutViewport()&&n,m=(s.left+(g&&null!=(o=null==(i=f.visualViewport)?void 0:i.offsetLeft)?o:0))/c,d=(s.top+(g&&null!=(r=null==(l=f.visualViewport)?void 0:l.offsetTop)?r:0))/a,u=s.width/c,p=s.height/a;return{width:u,height:p,top:d,right:m+u,bottom:d+p,left:m,x:m,y:d}}function getDocumentElement(t){return((isNode(t)?t.ownerDocument:t.document)||window.document).documentElement}function getNodeScroll(t){return isElement(t)?{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}:{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function getWindowScrollBarX(t){return getBoundingClientRect(getDocumentElement(t)).left+getNodeScroll(t).scrollLeft}function isScaled(t){const e=getBoundingClientRect(t);return round(e.width)!==t.offsetWidth||round(e.height)!==t.offsetHeight}function getRectRelativeToOffsetParent(t,e,n){const o=isHTMLElement(e),i=getDocumentElement(e),r=getBoundingClientRect(t,o&&isScaled(e),"fixed"===n);let l={scrollLeft:0,scrollTop:0};const s={x:0,y:0};if(o||!o&&"fixed"!==n)if(("body"!==getNodeName(e)||isOverflowElement(i))&&(l=getNodeScroll(e)),isHTMLElement(e)){const t=getBoundingClientRect(e,!0);s.x=t.x+e.clientLeft,s.y=t.y+e.clientTop}else i&&(s.x=getWindowScrollBarX(i));return{x:r.left+l.scrollLeft-s.x,y:r.top+l.scrollTop-s.y,width:r.width,height:r.height}}function getParentNode(t){return"html"===getNodeName(t)?t:t.assignedSlot||t.parentNode||(isShadowRoot(t)?t.host:null)||getDocumentElement(t)}function getTrueOffsetParent(t){return isHTMLElement(t)&&"fixed"!==getComputedStyle(t).position?t.offsetParent:null}function getContainingBlock(t){let e=getParentNode(t);for(isShadowRoot(e)&&(e=e.host);isHTMLElement(e)&&!["html","body"].includes(getNodeName(e));){if(isContainingBlock(e))return e;e=e.parentNode}return null}function getOffsetParent(t){const e=getWindow(t);let n=getTrueOffsetParent(t);for(;n&&isTableElement(n)&&"static"===getComputedStyle(n).position;)n=getTrueOffsetParent(n);return n&&("html"===getNodeName(n)||"body"===getNodeName(n)&&"static"===getComputedStyle(n).position&&!isContainingBlock(n))?e:n||getContainingBlock(t)||e}function getDimensions(t){if(isHTMLElement(t))return{width:t.offsetWidth,height:t.offsetHeight};const e=getBoundingClientRect(t);return{width:e.width,height:e.height}}function convertOffsetParentRelativeRectToViewportRelativeRect(t){let{rect:e,offsetParent:n,strategy:o}=t;const i=isHTMLElement(n),r=getDocumentElement(n);if(n===r)return e;let l={scrollLeft:0,scrollTop:0};const s={x:0,y:0};if((i||!i&&"fixed"!==o)&&(("body"!==getNodeName(n)||isOverflowElement(r))&&(l=getNodeScroll(n)),isHTMLElement(n))){const t=getBoundingClientRect(n,!0);s.x=t.x+n.clientLeft,s.y=t.y+n.clientTop}return{...e,x:e.x-l.scrollLeft+s.x,y:e.y-l.scrollTop+s.y}}function getViewportRect(t,e){const n=getWindow(t),o=getDocumentElement(t),i=n.visualViewport;let r=o.clientWidth,l=o.clientHeight,s=0,c=0;if(i){r=i.width,l=i.height;const t=isLayoutViewport();(t||!t&&"fixed"===e)&&(s=i.offsetLeft,c=i.offsetTop)}return{width:r,height:l,x:s,y:c}}function getDocumentRect(t){var e;const n=getDocumentElement(t),o=getNodeScroll(t),i=null==(e=t.ownerDocument)?void 0:e.body,r=max(n.scrollWidth,n.clientWidth,i?i.scrollWidth:0,i?i.clientWidth:0),l=max(n.scrollHeight,n.clientHeight,i?i.scrollHeight:0,i?i.clientHeight:0);let s=-o.scrollLeft+getWindowScrollBarX(t);const c=-o.scrollTop;return"rtl"===getComputedStyle$1(i||n).direction&&(s+=max(n.clientWidth,i?i.clientWidth:0)-r),{width:r,height:l,x:s,y:c}}function getNearestOverflowAncestor(t){const e=getParentNode(t);return["html","body","#document"].includes(getNodeName(e))?t.ownerDocument.body:isHTMLElement(e)&&isOverflowElement(e)?e:getNearestOverflowAncestor(e)}function getOverflowAncestors(t,e){var n;void 0===e&&(e=[]);const o=getNearestOverflowAncestor(t),i=o===(null==(n=t.ownerDocument)?void 0:n.body),r=getWindow(o),l=i?[r].concat(r.visualViewport||[],isOverflowElement(o)?o:[]):o,s=e.concat(l);return i?s:s.concat(getOverflowAncestors(l))}function contains(t,e){const n=null==e.getRootNode?void 0:e.getRootNode();if(t.contains(e))return!0;if(n&&isShadowRoot(n)){let n=e;do{if(n&&t===n)return!0;n=n.parentNode||n.host}while(n)}return!1}function getInnerBoundingClientRect(t,e){const n=getBoundingClientRect(t,!1,"fixed"===e),o=n.top+t.clientTop,i=n.left+t.clientLeft;return{top:o,left:i,x:i,y:o,right:i+t.clientWidth,bottom:o+t.clientHeight,width:t.clientWidth,height:t.clientHeight}}function getClientRectFromClippingAncestor(t,e,n){return"viewport"===e?rectToClientRect(getViewportRect(t,n)):isElement(e)?getInnerBoundingClientRect(e,n):rectToClientRect(getDocumentRect(getDocumentElement(t)))}function getClippingAncestors(t){const e=getOverflowAncestors(t),n=["absolute","fixed"].includes(getComputedStyle$1(t).position)&&isHTMLElement(t)?getOffsetParent(t):t;return isElement(n)?e.filter((t=>isElement(t)&&contains(t,n)&&"body"!==getNodeName(t))):[]}function getClippingRect(t){let{element:e,boundary:n,rootBoundary:o,strategy:i}=t;const r=[..."clippingAncestors"===n?getClippingAncestors(e):[].concat(n),o],l=r[0],s=r.reduce(((t,n)=>{const o=getClientRectFromClippingAncestor(e,n,i);return t.top=max(o.top,t.top),t.right=min(o.right,t.right),t.bottom=min(o.bottom,t.bottom),t.left=max(o.left,t.left),t}),getClientRectFromClippingAncestor(e,l,i));return{width:s.right-s.left,height:s.bottom-s.top,x:s.left,y:s.top}}const platform={getClippingRect:getClippingRect,convertOffsetParentRelativeRectToViewportRelativeRect:convertOffsetParentRelativeRectToViewportRelativeRect,isElement:isElement,getDimensions:getDimensions,getOffsetParent:getOffsetParent,getDocumentElement:getDocumentElement,getElementRects:t=>{let{reference:e,floating:n,strategy:o}=t;return{reference:getRectRelativeToOffsetParent(e,getOffsetParent(n),o),floating:{...getDimensions(n),x:0,y:0}}},getClientRects:t=>Array.from(t.getClientRects()),isRTL:t=>"rtl"===getComputedStyle$1(t).direction};function autoUpdate(t,e,n,o){void 0===o&&(o={});const{ancestorScroll:i=!0,ancestorResize:r=!0,elementResize:l=!0,animationFrame:s=!1}=o,c=i&&!s,a=r&&!s,f=c||a?[...isElement(t)?getOverflowAncestors(t):[],...getOverflowAncestors(e)]:[];f.forEach((t=>{c&&t.addEventListener("scroll",n,{passive:!0}),a&&t.addEventListener("resize",n)}));let g,m=null;if(l){let o=!0;m=new ResizeObserver((()=>{o||n(),o=!1})),isElement(t)&&!s&&m.observe(t),m.observe(e)}let d=s?getBoundingClientRect(t):null;return s&&function e(){const o=getBoundingClientRect(t);!d||o.x===d.x&&o.y===d.y&&o.width===d.width&&o.height===d.height||n(),d=o,g=requestAnimationFrame(e)}(),n(),()=>{var t;f.forEach((t=>{c&&t.removeEventListener("scroll",n),a&&t.removeEventListener("resize",n)})),null==(t=m)||t.disconnect(),m=null,s&&cancelAnimationFrame(g)}}const computePosition=(t,e,n)=>computePosition$1(t,e,{platform:platform,...n});export{autoUpdate as a,size as b,computePosition as c,flip as f,offset as o,shift as s};